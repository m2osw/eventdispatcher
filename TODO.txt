
* See to have clients and servers for HTTP/HTTPS/HTTP2/HTTP3
  (we already have such in libsnapwebsites, only it uses `snapuri` -> edhttp)

* Config describing allowed messages with their parameters and values for
  such and a way to track which message was ever sent (i.e. a form of
  message coverage) so we can verify that all messages were checked
  (i.e. for debug purposes).

* When adding a dispatcher match, detect whether it was already added; when
  we add a message such as STATUS once, then trying to add it again will have
  no effect (the 2nd and further instances are ignored because we stop after
  executing the first); the add_match() function should be capable of
  deteting such (atl east in DEBUG mode) so we know we did that mistake;
  the execution method could also no return and see if it can match more than
  one entry (which is acceptable if using a regex... so we need to be careful
  here--in this case, it may just be a warning)

* The inotify listens to either a specific file or a directory. It does not
  listen for events in sub-directories. We want to add a RECURSIVE flag to
  support that feature. This means whenever we add a new watch, we also need
  to emit events for files found in those sub-directories at the time we add
  the new watch (in which case we may want another feature which is to send
  an event for all existing files after starting a new watch, with a type such
  as EXISTS).

* Local sockets represented by files can use permissions to control the
  security (under Linux). Right now, I use 0666 in the communicatord in
  order to let people connect to the service. I would like to instead
  make use of a specific group (i.e. something like "communicator-user")
  and make sure that users of the communicatord are part of that group.
  Here we would need to support changing the group of the socket and
  then set the permissions accordingly (i.e. 0660 instead of 0666).

* A service to track changes to the list of opened/closed network connections

  My existing code does not work properly, we can determine what is opened
  and closed, but we do not get events when the state changes... I got a
  message about it on Stackoverflow and a link to here:

      https://github.com/sivasankariit/iproute2/blob/master/misc/ss.c
      https://stackoverflow.com/questions/68425240/can-the-netlink-sock-diag-interface-be-used-to-listen-for-listen-and-close?noredirect=1#comment132999023_68425240

  which may be useful to further out the existing code and make it work.

  One way may be to list for file changes under /proc/... as it may have the
  effect we want (i.e. whenever a new file is created there, such as a UDP
  connection, then we would receive a message and can tranform that in a
  signal about new/removed TCP/UDP/... connections (however file_change--a.k.a.
  inotify does not work there).

* Finish the snaplogger network appender extension (mainly testing now).

* Consider moving the cppprocess tee_pipe to eventdispatcher.

* Update \file documentation to match the corresponding class. These were
  copied/pasted in all the files when I did the big break up and most are
  still not updated.

* Update the dispatcher classes documentation to match the new scheme (the
  callback instead of a function offset in one class).

* Rate limit transfers by sending X bytes every N milliseconds on that given
  connection (i.e. as long as there is something to write and it can be written
  to that file descriptor, sleep N milliseconds and then send another X bytes).

  As our poll() loop stands, this is not quite feasible. But we can look at
  testing whether the connection has data to be written, then also check on
  the "rate limited" feature, if turned on (N is not 0?), then check whether
  we should wait on the fd to become available (i.e. time to send more data)
  or view the connection as a timer (i.e. we still need to wait some more).
  The current use of the timer right now is a form of Inclusive OR, this other
  method would make it a form of Exclusive OR. But we probably want to use a
  different timestamp tracker which get reassigned a "now + N" whenever a
  write happened. But for the limit to work properly, we need to know the
  amount of data sent and whether we should send more and how much more...

* Short `connect()` timeout is possible by making the socket non-blocking
  before calling the function; then we can `poll()` on the socket and get
  a POLLOUT event once the socket is connected; this can be useful in some
  situations, many times it's probably not that necessary, except that has
  been a bottleneck in the permanent TCP connection implementation and is
  why we use a thread for the connect to happen in parallel... that would
  not be required anymore (but it adds a new state "in-limbo while
  connecting").

  From the `connect()` man page:

       EINPROGRESS
              The socket is nonblocking and the connection cannot be
              completed immediately. It is possible to select(2) or
              poll(2) for completion by selecting the socket for writing.
              After select(2) indicates writability, use getsockopt(2) to
              read the SO_ERROR option at level SOL_SOCKET to determine
              whether connect() completed successfully (SO_ERROR is zero)
              or unsuccessfully (SO_ERROR is one of the usual error codes
              listed here, explaining the reason for the failure).

  **IMPORTANT:** when `connect()` returns, it may already have connected and
                 return 0. You need to enter the intermediate state only if
                 `connect()` returns `EINPROGRESS`.

  See: https://stackoverflow.com/questions/2597608/c-socket-connection-timeout

* Add support for any number of timers in a connection. I often run in
  problems with this because I need two or three different timers then
  I have to create sub-objects, which are separate connection timers by
  themselves. We can have an identifier to recognize which timer times
  out and pass that parameter to the process_timeout() function.
  Another solution would be to have a way to quickly create a timer
  without having to create a sub-class, so that way we could keep it
  separate (clean) and have a callback instead of a virtual function
  (and we have a callback thingy to manage lists of callbacks in snapdev).

* Ideas on how to re-implement the whole thing using templates to avoid
  duplicating the buffering & message handling in each class (instead pass
  a "trait" or something of the sort)

  See a compiling version in `connection_t.h/cpp`. This would allow me to
  have one class create "many" connections and handle all the events as it
  sees fit instead of having to derive from each one of these "many"
  connections and reimplement the callbacks in each one of them.

  current design:

      connection
        ^
        +-- tcp_client_connection
              ^
              +-- tcp_client_buffer_connection
                    ^
                    +-- tcp_client_message_connection
                          ^
                          +-- tcp_client_permanent_message_connection

  and I repeat that for local_stream, udp, pipe, etc. when the only thing
  we really need is a connection implementation, then everything else can
  be done using a trait

  the basic connection remains pretty much the same, these are viewed as
  connection traits:

      base_connection
        ^
        +-- tcp_client_connection
        |
        +-- udp_client_connection
        |
        +-- ...

  the rest becomes template classes where ConnectionT is one of the basic
  connections defined above:

      template<
            typename BaseConnectionT
          , typename EventHandlerT>
      class connection
          : public BaseConnectionT
      {
          connection(EventHandlerT * event_handler)
              : f_event_handler(event_handler)
          {
          }

          virtual void process_timer() override
          {
              if constexpr (std::is_member_function_pointer_v<decltype(&EventHandlerT::process_timer)>)
              {
                  f_event_handler.process_timer();
              }
              else
              {
                  SNAP_LOG_WARNING
                      << "connection \""
                      << get_name()
                      << "\" received a process_timer() event without a corresponding event handler."
                      << SNAP_LOG_SEND;
              }
          }

          ...repeat for each possible event in BaseConnectionT...
      };

      template<
            typename BaseConnectionT
          , typename EventHandlerT>
      class buffering
          : public connection<BaseConnectionT, EventHandlerT>
      {
      };

      template<
            typename BaseConnectionT
          , typename EventHandlerT>
      class messenger
          : public buffering<BaseConnectionT, EventHandlerT>
      {
      };

  The traits are plain classes and we can test whether they have a given
  function to know whether we can call it or not.

    using a template we can have "traits" that allow us to have implementations
    of the connection, read, write, buffering, etc. so for messages we can have
    one implementation instead of one per connection type

    the result is a way to create connections with a set of traits more or
    less like so:

      template<
          class ConnectionT,    // Timer, TCP, UDP, Unix, Pipe, SignalFD, ...
          class Traits,         // read/write, buffering, message
          class Allocator = std::allocator<CharT>>
      class connection
      {
      };


# vim: ts=4 sw=4 et
